# SLSA (Supply-chain Levels for Software Artifacts)

Comprehensive reference for the SLSA framework — a security maturity model for protecting software artifact integrity through provenance, attestation, and build platform hardening.

## Overview

**Full name**: Supply-chain Levels for Software Artifacts (pronounced "salsa")
**Maintainer**: OpenSSF (Open Source Security Foundation) under the Linux Foundation
**Current version**: v1.2 (November 2025)
**Website**: https://slsa.dev
**Specification**: https://slsa.dev/spec/v1.2/

SLSA originated from Google's internal Binary Authorization for Borg (BAB) system, which has been used since ~2013 to enforce build and provenance requirements for production workloads. Google open-sourced the concept as SLSA in 2021, and OpenSSF adopted it as an official project.

**Purpose**: SLSA provides a checklist of standards and controls to prevent tampering, improve integrity, and secure packages and infrastructure across the software supply chain. It defines concrete, incremental maturity levels that organizations can adopt progressively.

**What SLSA is NOT**: SLSA is not a control catalog like NIST 800-53 or ISO 27001. It is a maturity model with tracks and levels. It does not prescribe organizational policies or comprehensive security programs — it focuses specifically on artifact integrity and provenance.

## Version History

| Version | Date | Key Changes |
|---------|------|-------------|
| v0.1 | Sep 2021 | Initial proposal (single track, L1-L4) |
| v1.0 | Apr 2023 | First stable release; restructured into tracks; removed L4; Build track finalized |
| v1.1 | Apr 2025 | Refined Build track requirements; draft Source track added |
| v1.2 | Nov 2025 | Finalized Source track (L1-L4); current version |

**Breaking change in v1.0**: The original L4 ("Hermetic + reproducible") was removed. The pre-v1.0 single-track model was replaced with independent tracks. Content referencing SLSA L4 for builds or hermetic build requirements is outdated.

## Track Model

SLSA uses a **track-based architecture** where each track addresses a different aspect of supply chain security. Tracks are independent — an artifact can be at different levels in different tracks.

| Track | Focus | Levels | Status in v1.2 |
|-------|-------|--------|-----------------|
| **Build** | Artifact build integrity and provenance | L0–L3 | Finalized (since v1.0) |
| **Source** | Source code integrity and version control | L1–L4 | Finalized (v1.2) |

Each level within a track builds on the previous one. Organizations should progress incrementally — reaching L1 across tracks provides more value than reaching L3 in only one track.

## Build Track (L0–L3)

The Build track ensures that artifacts are built correctly, and that provenance metadata accurately describes how an artifact was produced.

### Build L0 — No guarantees

No SLSA requirements. Represents the baseline state before any SLSA adoption.

- No provenance
- No guarantees about the build process
- Typical of ad-hoc or manual build processes

### Build L1 — Provenance exists

The build process produces provenance describing how the artifact was built, and the provenance is available to consumers.

**Requirements**:
- Build process exists (scripted/automated, not manual)
- Provenance is generated describing the build (builder, source, build process)
- Provenance is available to consumers (published alongside the artifact)
- Provenance format follows the SLSA provenance schema

**What this prevents**: Provides a starting point for artifact traceability. Consumers can at least see what produced the artifact, even if the provenance is not yet tamper-proof.

### Build L2 — Signed provenance

Provenance is generated by a hosted build platform and is authenticated (signed). Consumers can verify provenance authenticity.

**Requirements**:
- All L1 requirements
- Build runs on a hosted build platform (not a developer workstation)
- Provenance is signed by the build platform (not the build tenant/developer)
- Provenance signature is verifiable by consumers
- Build platform has a documented process for signing key management

**What this prevents**: Tampering with provenance after generation. Consumers can verify that provenance was generated by the claimed build platform and has not been modified.

### Build L3 — Hardened builds

The build platform provides strong isolation between build environments and protects the integrity of the provenance signing process.

**Requirements**:
- All L2 requirements
- Build environments are isolated from one another (e.g., ephemeral containers, VMs)
- Build environments are isolated from the build platform's control plane
- Provenance signing keys are protected from tenant access (the build process cannot exfiltrate or modify the signing key)
- The build platform prevents tenants from influencing another tenant's build
- Provenance includes sufficient metadata to verify these properties

**What this prevents**: Insider threats and compromised build tenants. Even if an attacker controls the build definition, they cannot forge provenance, access other tenants' builds, or tamper with the signing infrastructure.

## Source Track (L1–L4)

The Source track (finalized in v1.2) ensures that source code has a clear history, is protected from unauthorized modification, and is reviewed before incorporation.

### Source L1 — Version controlled

Source code is maintained in a version control system.

**Requirements**:
- Source is stored in a version control system (VCS)
- Every revision has a unique, immutable identifier
- The VCS tracks the identity of who made each revision

**What this prevents**: Loss of source history, inability to determine what code was used to build an artifact.

### Source L2 — History and provenance

Source revisions have a verifiable history and provenance.

**Requirements**:
- All L1 requirements
- Revision history is preserved and cannot be deleted
- Source provenance metadata exists (who, when, what parent revision)
- Source platform authenticates contributor identity (beyond self-asserted)

**What this prevents**: History rewriting attacks, unattributed changes. Provides a basis for auditing who changed what and when.

### Source L3 — Continuous technical controls

Technical controls are applied to every change automatically by the source platform.

**Requirements**:
- All L2 requirements
- The source platform enforces branch protection rules (e.g., no force-push to release branches)
- Changes go through a defined, platform-enforced process before landing on protected branches
- The platform provides tamper-evident logs of all changes to branch protection settings

**What this prevents**: Circumvention of change management processes, undetected modifications to the build source.

### Source L4 — Two-party review

Every change to the source is reviewed and approved by a person other than the author.

**Requirements**:
- All L3 requirements
- Every change to protected branches requires review by at least one person who is not the author
- Review is enforced by the source platform (not just policy)
- Reviewer identity is recorded and verifiable

**What this prevents**: Single-person compromise scenarios (e.g., a maintainer account takeover alone is insufficient to inject malicious code).

## Key Concepts

### Provenance

A metadata record that describes how a software artifact was produced. Answers: what was built, who built it, from what source, using what build process, and on what build platform. Provenance is the central artifact in the SLSA model.

### Attestation

A signed statement about a software artifact. SLSA uses the **in-toto attestation framework** with **DSSE (Dead Simple Signing Envelope)** for the signature layer. An attestation binds a subject (the artifact, identified by digest) to a predicate (the claims about it, such as provenance).

### Verification Summary Attestation (VSA)

A higher-order attestation issued by a verification authority stating that an artifact meets a specific SLSA level. Useful in supply chains where downstream consumers cannot or do not perform full provenance verification themselves — they trust a verification authority's VSA instead.

### Build Platform

The infrastructure that executes the build process and generates provenance. At L2+, the build platform must be hosted (not a developer laptop) and must sign provenance. At L3, it must provide isolation guarantees. Examples: GitHub Actions, Google Cloud Build, Tekton.

### Isolation

At Build L3, the build platform must enforce isolation between:
- **Tenant isolation**: One build tenant cannot affect another tenant's build or provenance
- **Control plane isolation**: The build process cannot access the build platform's control plane or signing keys
- **Environment isolation**: Build environments are ephemeral and cleaned between runs

## Provenance Format

SLSA provenance follows the **in-toto attestation framework** specification.

### Structure

```
DSSE Envelope {
  payloadType: "application/vnd.in-toto+json"
  payload: {
    _type: "https://in-toto.io/Statement/v1"
    subject: [{ name, digest }]         // The artifact(s)
    predicateType: "https://slsa.dev/provenance/v1"
    predicate: {
      buildDefinition: {
        buildType: "<URI>"              // Type of build (e.g., GitHub Actions workflow)
        externalParameters: { ... }     // User-controlled inputs (source repo, ref, workflow)
        internalParameters: { ... }     // Platform-controlled values
        resolvedDependencies: [ ... ]   // Resolved inputs (source commit, base images)
      }
      runDetails: {
        builder: { id, version }        // Build platform identity
        metadata: {
          invocationId: "..."           // Unique build invocation ID
          startedOn: "..."              // Timestamp
          finishedOn: "..."
        }
      }
    }
  }
  signatures: [{ keyid, sig }]
}
```

### Key Fields

| Field | Purpose |
|-------|---------|
| `subject` | Identifies the artifact by name and cryptographic digest (SHA-256) |
| `predicateType` | Must be `https://slsa.dev/provenance/v1` for SLSA provenance |
| `buildType` | URI identifying the build system type (determines schema of parameters) |
| `externalParameters` | Inputs controlled by the build tenant (source ref, workflow file) |
| `resolvedDependencies` | Immutable references to all resolved inputs (pinned digests) |
| `builder.id` | URI identifying the build platform |

## Tooling

### Provenance Generation

| Tool | Description |
|------|-------------|
| **slsa-github-generator** | GitHub Actions reusable workflows that generate SLSA L3 provenance for Go, containers, Node.js, and generic artifacts |
| **Tekton Chains** | Kubernetes-native supply chain security; automatically generates SLSA provenance for Tekton pipeline runs |
| **FRSCA** | Factory for Repeatable Secure Creation of Artifacts — reference architecture for SLSA-compliant build pipelines |

### Provenance Verification

| Tool | Description |
|------|-------------|
| **slsa-verifier** | Official CLI tool for verifying SLSA provenance of artifacts built with slsa-github-generator |
| **Cosign** (Sigstore) | Signs and verifies container images and other artifacts; supports in-toto attestation storage |
| **Kyverno** | Kubernetes policy engine that can enforce SLSA provenance verification on container admission |

### Signing and Transparency Infrastructure

| Tool | Description |
|------|-------------|
| **Sigstore** | Umbrella project for keyless signing of software artifacts |
| **Fulcio** | Sigstore component — issues short-lived code signing certificates based on OIDC identity |
| **Rekor** | Sigstore component — immutable transparency log for signed attestations |
| **Cosign** | Sigstore component — signing/verification CLI for containers and blobs |

### Supply Chain Analysis

| Tool | Description |
|------|-------------|
| **GUAC** (Graph for Understanding Artifact Composition) | Aggregates and queries software supply chain metadata (SBOMs, SLSA provenance, vulnerability data) into a graph database |

## Adoption

SLSA has seen significant adoption across major software platforms and ecosystems:

| Adopter | SLSA Level | Details |
|---------|------------|---------|
| **Google** | L3 (internal) | BAB (precursor to SLSA) enforced in production since ~2013 |
| **GitHub** | L3 (via Actions) | slsa-github-generator provides L3 provenance for Actions-built artifacts |
| **npm** | L3 (registry) | npm generates SLSA L3 provenance for packages built via GitHub Actions |
| **PyPI** | L3 (registry) | PyPI supports publishing SLSA provenance for packages via Trusted Publishers |
| **Docker BuildKit** | L1 (provenance) | BuildKit generates SLSA provenance for container image builds by default |
| **Homebrew** | L2 | Homebrew generates signed provenance for bottle builds |
| **Chainguard** | L3 | Chainguard Images are built with SLSA L3 provenance |

## Relationship to NIST Frameworks

SLSA is not a replacement for NIST 800-53 or any federal framework. It is a complementary maturity model that provides concrete, technical implementation guidance for supply chain integrity — an area where NIST controls tend to be high-level and policy-oriented.

### NIST 800-53 SR Family Mappings

| NIST Control | SLSA Relationship |
|-------------|-------------------|
| **SR-3** (Supply Chain Controls and Processes) | SLSA Build L1+ provides provenance as a concrete implementation of component traceability. SLSA Build L2+ provides signed provenance as supply chain verification. |
| **SR-4** (Provenance) | SLSA directly addresses provenance. Build L1 = provenance exists; L2 = authenticated provenance; L3 = tamper-resistant provenance. Source track adds source-level provenance. |
| **SR-11** (Component Authenticity) | SLSA provenance verification and Sigstore signing provide concrete mechanisms for verifying component authenticity and integrity. |
| **SA-8** (Security and Privacy Engineering Principles) | SLSA L3 build isolation and key protection implement supply chain security engineering principles. |

### NIST 800-218 (SSDF) Complement

The Secure Software Development Framework (SSDF, SP 800-218) defines practices for secure software development. SLSA complements SSDF by providing:
- **PO.1.3** (security requirements for software) → SLSA levels serve as concrete requirements
- **PS.1** (protect all forms of code from unauthorized access and tampering) → Source track L3-L4
- **PS.3** (archive and protect each release) → Build track L1+ (provenance) + Sigstore (transparency log)
- **PW.4** (reuse existing well-secured software) → SLSA provenance verification of dependencies

### Executive Order 14028 Context

EO 14028 (May 2021, "Improving the Nation's Cybersecurity") mandated SBOM delivery and supply chain security for software sold to the federal government. SLSA provides a concrete implementation path for the EO's supply chain integrity requirements. Several NIST publications issued in response to EO 14028 reference or align with SLSA concepts, particularly around provenance, attestation, and build integrity.

## Key References

| Resource | URL |
|----------|-----|
| SLSA website | https://slsa.dev |
| Specification (v1.2) | https://slsa.dev/spec/v1.2/ |
| Build track specification | https://slsa.dev/spec/v1.2/levels#build-track |
| Source track specification | https://slsa.dev/spec/v1.2/levels#source-track |
| Provenance format | https://slsa.dev/spec/v1.2/provenance |
| In-toto attestation framework | https://github.com/in-toto/attestation |
| slsa-github-generator | https://github.com/slsa-framework/slsa-github-generator |
| slsa-verifier | https://github.com/slsa-framework/slsa-verifier |
| SLSA GitHub org | https://github.com/slsa-framework |
| Sigstore | https://sigstore.dev |
| GUAC | https://guac.sh |
