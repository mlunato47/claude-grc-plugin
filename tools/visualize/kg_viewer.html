<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GRC Knowledge Graph Viewer</title>
<script src="https://unpkg.com/cytoscape@3.30.4/dist/cytoscape.min.js"></script>
<script src="https://unpkg.com/marked@15.0.4/marked.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: #0f172a; color: #e2e8f0; height: 100vh;
    display: grid; grid-template-rows: auto 1fr auto;
    grid-template-columns: 220px 1fr 300px;
    overflow: hidden;
  }

  /* Header */
  header {
    grid-column: 1 / -1; padding: 10px 16px;
    background: #1e293b; border-bottom: 1px solid #334155;
    display: flex; align-items: center; gap: 16px;
  }
  header h1 { font-size: 16px; font-weight: 600; white-space: nowrap; }
  header .stats { font-size: 12px; color: #94a3b8; white-space: nowrap; }
  header input[type="text"] {
    flex: 1; max-width: 320px; padding: 6px 10px;
    background: #0f172a; border: 1px solid #475569; border-radius: 6px;
    color: #e2e8f0; font-size: 13px; outline: none;
  }
  header input[type="text"]:focus { border-color: #3b82f6; }
  header .actions { display: flex; gap: 6px; margin-left: auto; }
  header button {
    padding: 5px 10px; background: #334155; border: 1px solid #475569;
    border-radius: 5px; color: #e2e8f0; font-size: 12px; cursor: pointer;
  }
  header button:hover { background: #475569; }

  /* Sidebar */
  aside {
    background: #1e293b; border-right: 1px solid #334155;
    padding: 12px; overflow-y: auto; font-size: 13px;
  }
  aside h3 { font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; color: #64748b; margin: 12px 0 6px; }
  aside h3:first-child { margin-top: 0; }
  aside label {
    display: flex; align-items: center; gap: 6px; padding: 3px 0; cursor: pointer;
  }
  aside label input { cursor: pointer; }
  .color-dot {
    display: inline-block; width: 10px; height: 10px; border-radius: 50%;
    flex-shrink: 0;
  }
  .plane-line {
    display: inline-block; width: 16px; height: 3px; flex-shrink: 0; border-radius: 1px;
  }
  aside .layout-select { margin-top: 8px; }
  aside select {
    width: 100%; padding: 5px 6px; background: #0f172a; border: 1px solid #475569;
    border-radius: 5px; color: #e2e8f0; font-size: 12px;
  }

  /* Canvas */
  #cy {
    background: #0f172a; position: relative;
  }

  /* Detail panel */
  #detail {
    background: #1e293b; border-left: 1px solid #334155;
    padding: 12px; overflow-y: auto; font-size: 13px;
  }
  #detail.empty { display: flex; align-items: center; justify-content: center; color: #64748b; }
  #detail h2 { font-size: 14px; font-weight: 600; margin-bottom: 8px; word-break: break-all; }
  #detail .badge {
    display: inline-block; padding: 2px 8px; border-radius: 10px;
    font-size: 11px; font-weight: 500; margin-bottom: 10px;
  }
  #detail table { width: 100%; border-collapse: collapse; }
  #detail td { padding: 4px 0; vertical-align: top; }
  #detail td:first-child { color: #94a3b8; width: 100px; padding-right: 8px; }
  #detail td:last-child { word-break: break-word; }
  #detail .section-label {
    font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;
    color: #64748b; margin: 14px 0 6px; border-top: 1px solid #334155; padding-top: 10px;
  }
  #detail ul { list-style: none; padding: 0; }
  #detail ul li {
    padding: 3px 0; cursor: pointer; color: #93c5fd;
  }
  #detail ul li:hover { color: #60a5fa; text-decoration: underline; }

  /* Chat drawer */
  #chat-drawer {
    grid-column: 1 / -1;
    background: #1e293b;
    border-top: 1px solid #334155;
    display: flex; flex-direction: column;
    max-height: 50vh;
    transition: max-height 0.3s ease;
  }
  #chat-drawer.collapsed {
    max-height: 0; overflow: hidden; border-top: none;
  }
  #chat-header {
    display: flex; align-items: center; gap: 10px;
    padding: 8px 16px;
    background: #1e293b; border-bottom: 1px solid #334155;
    cursor: pointer; user-select: none; flex-shrink: 0;
  }
  #chat-header h3 { font-size: 13px; font-weight: 600; flex: 1; }
  #chat-header .chat-toggle { font-size: 18px; color: #94a3b8; }
  #chat-header .chat-status { font-size: 11px; color: #64748b; }
  #chat-messages {
    flex: 1; overflow-y: auto; padding: 12px 16px;
    display: flex; flex-direction: column; gap: 10px;
    min-height: 0;
  }
  .chat-msg { max-width: 85%; padding: 8px 12px; border-radius: 8px; font-size: 13px; line-height: 1.5; }
  .chat-msg.user { align-self: flex-end; background: #3b82f6; color: #fff; }
  .chat-msg.assistant {
    align-self: flex-start; background: #334155; color: #e2e8f0;
  }
  .chat-msg.assistant p { margin: 0 0 8px; }
  .chat-msg.assistant p:last-child { margin-bottom: 0; }
  .chat-msg.assistant ul, .chat-msg.assistant ol { margin: 4px 0; padding-left: 20px; }
  .chat-msg.assistant code { background: #1e293b; padding: 1px 4px; border-radius: 3px; font-size: 12px; }
  .chat-msg.assistant pre { background: #0f172a; padding: 8px; border-radius: 4px; overflow-x: auto; margin: 6px 0; }
  .chat-msg.assistant pre code { background: none; padding: 0; }
  .chat-msg.assistant table { border-collapse: collapse; margin: 6px 0; font-size: 12px; }
  .chat-msg.assistant th, .chat-msg.assistant td { border: 1px solid #475569; padding: 4px 8px; text-align: left; }
  .chat-msg.assistant th { background: #1e293b; }
  .chat-msg.assistant a.node-link {
    color: #93c5fd; cursor: pointer; text-decoration: underline;
    text-decoration-style: dotted;
  }
  .chat-msg.assistant a.node-link:hover { color: #60a5fa; }
  .chat-msg.error { align-self: center; background: #7f1d1d; color: #fca5a5; font-size: 12px; }
  #chat-input-bar {
    display: flex; gap: 8px; padding: 8px 16px;
    border-top: 1px solid #334155; flex-shrink: 0;
  }
  #chat-input {
    flex: 1; padding: 8px 12px; background: #0f172a; border: 1px solid #475569;
    border-radius: 6px; color: #e2e8f0; font-size: 13px; outline: none;
    font-family: inherit; resize: none;
  }
  #chat-input:focus { border-color: #3b82f6; }
  #chat-send {
    padding: 8px 16px; background: #3b82f6; border: none;
    border-radius: 6px; color: #fff; font-size: 13px; cursor: pointer;
    font-weight: 500; white-space: nowrap;
  }
  #chat-send:hover { background: #2563eb; }
  #chat-send:disabled { background: #475569; cursor: not-allowed; }
  header button.active { background: #3b82f6; border-color: #3b82f6; }
</style>
</head>
<body>
  <header>
    <h1>GRC Knowledge Graph</h1>
    <span class="stats" id="stats">Loading...</span>
    <input type="text" id="search" placeholder="Search nodes (e.g. AC-2, SOC2, HIPAA)..." />
    <div class="actions">
      <button id="btn-fit" title="Fit graph to view">Fit</button>
      <button id="btn-reset" title="Reset view and clear selection">Reset</button>
      <button id="btn-png" title="Export as PNG">PNG</button>
      <button id="btn-chat" title="Toggle chat with Claude">Chat</button>
    </div>
  </header>

  <aside>
    <h3>Graph Planes</h3>
    <div id="plane-filters"></div>

    <h3>Node Types</h3>
    <div id="type-filters"></div>

    <h3>Layout</h3>
    <div class="layout-select">
      <select id="layout-select">
        <option value="cose">Force-Directed (cose)</option>
        <option value="breadthfirst">Hierarchy (breadthfirst)</option>
        <option value="concentric">Concentric</option>
        <option value="circle">Circle</option>
      </select>
    </div>

    <h3>Visibility</h3>
    <label>
      <input type="checkbox" id="toggle-labels" checked />
      Show labels
    </label>
    <label>
      <input type="checkbox" id="toggle-orphans" checked />
      Show orphaned nodes
    </label>
  </aside>

  <div id="cy"></div>

  <div id="detail" class="empty">
    <span>Click a node or edge to inspect</span>
  </div>

  <div id="chat-drawer" class="collapsed">
    <div id="chat-header">
      <h3>Chat with Claude</h3>
      <span class="chat-status" id="chat-status"></span>
      <span class="chat-toggle" id="chat-toggle-icon">&#9650;</span>
    </div>
    <div id="chat-messages"></div>
    <div id="chat-input-bar">
      <textarea id="chat-input" rows="1" placeholder="Ask about the graph (e.g., &quot;What frameworks are loaded?&quot;)"></textarea>
      <button id="chat-send">Send</button>
    </div>
  </div>

  <script>
    // -- Config --
    const NODE_COLORS = {
      Framework:     '#3b82f6',
      ControlFamily: '#8b5cf6',
      Control:       '#10b981',
      Baseline:      '#f59e0b',
      ServiceModel:  '#ef4444',
      EvidenceType:  '#06b6d4',
      DocumentType:  '#6b7280',
    };
    const NODE_SHAPES = {
      Framework:     'diamond',
      ControlFamily: 'round-rectangle',
      Control:       'ellipse',
      Baseline:      'pentagon',
      ServiceModel:  'hexagon',
      EvidenceType:  'rectangle',
      DocumentType:  'rectangle',
    };
    const NODE_SIZES = {
      Framework: 40, ControlFamily: 28, Control: 18,
      Baseline: 24, ServiceModel: 28, EvidenceType: 22, DocumentType: 22,
    };
    const PLANE_COLORS = {
      COMPLIANCE:     '#6b7280',
      MAPPING:        '#3b82f6',
      RESPONSIBILITY: '#ef4444',
      EVIDENCE:       '#06b6d4',
    };
    const PLANE_STYLES = {
      COMPLIANCE:     'solid',
      MAPPING:        'dashed',
      RESPONSIBILITY: 'solid',
      EVIDENCE:       'dotted',
    };

    let cy, graphData;

    // -- Init --
    async function init() {
      const res = await fetch('/api/graph');
      graphData = await res.json();

      const elements = [];

      // Nodes
      graphData.nodes.forEach(n => {
        elements.push({
          group: 'nodes',
          data: { id: n.id, label: n.label, type: n.type, ...n.props },
          classes: n.type,
        });
      });

      // Edges
      graphData.edges.forEach((e, i) => {
        elements.push({
          group: 'edges',
          data: {
            id: `e${i}`, source: e.source, target: e.target,
            predicate: e.predicate, plane: e.plane,
            confidence: e.confidence, meta: e.meta,
          },
          classes: e.plane,
        });
      });

      // Build style array
      const style = [
        // Defaults
        { selector: 'node', style: {
          'label': 'data(id)', 'font-size': 8, 'color': '#cbd5e1',
          'text-valign': 'bottom', 'text-margin-y': 4,
          'min-zoomed-font-size': 6,
          'text-max-width': 80, 'text-wrap': 'ellipsis',
        }},
        { selector: 'edge', style: {
          'width': 1.5, 'curve-style': 'bezier',
          'target-arrow-shape': 'triangle', 'arrow-scale': 0.6,
          'opacity': 0.6,
        }},
        { selector: 'node.highlighted', style: {
          'border-width': 3, 'border-color': '#fbbf24',
          'z-index': 100,
        }},
        { selector: 'node:selected', style: {
          'border-width': 3, 'border-color': '#f472b6',
        }},
        { selector: 'edge:selected', style: {
          'width': 3, 'opacity': 1, 'z-index': 100,
        }},
        { selector: 'node.neighbor', style: {
          'border-width': 2, 'border-color': '#fbbf24', 'opacity': 1,
        }},
        { selector: 'node.dimmed', style: { 'opacity': 0.15 }},
        { selector: 'edge.dimmed', style: { 'opacity': 0.05 }},
      ];

      // Node type styles
      Object.entries(NODE_COLORS).forEach(([type, color]) => {
        style.push({ selector: `node.${type}`, style: {
          'background-color': color,
          'shape': NODE_SHAPES[type] || 'ellipse',
          'width': NODE_SIZES[type] || 20,
          'height': NODE_SIZES[type] || 20,
        }});
      });

      // Edge plane styles
      Object.entries(PLANE_COLORS).forEach(([plane, color]) => {
        style.push({ selector: `edge.${plane}`, style: {
          'line-color': color,
          'target-arrow-color': color,
          'line-style': PLANE_STYLES[plane] || 'solid',
        }});
      });

      cy = cytoscape({
        container: document.getElementById('cy'),
        elements,
        style,
        layout: { name: 'cose', animate: false, nodeRepulsion: () => 12000, idealEdgeLength: () => 80, nodeDimensionsIncludeLabels: true },
        minZoom: 0.1, maxZoom: 5,
        wheelSensitivity: 0.3,
      });

      // Events
      cy.on('tap', 'node', onNodeTap);
      cy.on('tap', 'edge', onEdgeTap);
      cy.on('tap', (evt) => { if (evt.target === cy) clearSelection(); });

      buildFilters();
      updateStats();
    }

    // -- Filters --
    function buildFilters() {
      const planeDiv = document.getElementById('plane-filters');
      Object.keys(PLANE_COLORS).forEach(plane => {
        const label = document.createElement('label');
        const cb = document.createElement('input');
        cb.type = 'checkbox'; cb.checked = true; cb.dataset.plane = plane;
        cb.addEventListener('change', applyFilters);
        const dot = document.createElement('span');
        dot.className = 'plane-line';
        dot.style.background = PLANE_COLORS[plane];
        if (PLANE_STYLES[plane] === 'dashed') dot.style.background = `repeating-linear-gradient(90deg, ${PLANE_COLORS[plane]} 0 4px, transparent 4px 6px)`;
        if (PLANE_STYLES[plane] === 'dotted') dot.style.background = `repeating-linear-gradient(90deg, ${PLANE_COLORS[plane]} 0 2px, transparent 2px 5px)`;
        label.append(cb, dot, ` ${plane.charAt(0)}${plane.slice(1).toLowerCase()}`);
        planeDiv.appendChild(label);
      });

      const typeDiv = document.getElementById('type-filters');
      Object.keys(NODE_COLORS).forEach(type => {
        const label = document.createElement('label');
        const cb = document.createElement('input');
        cb.type = 'checkbox'; cb.checked = true; cb.dataset.nodeType = type;
        cb.addEventListener('change', applyFilters);
        const dot = document.createElement('span');
        dot.className = 'color-dot'; dot.style.background = NODE_COLORS[type];
        label.append(cb, dot, ` ${type}`);
        typeDiv.appendChild(label);
      });
    }

    function applyFilters() {
      // Planes
      const activePlanes = new Set();
      document.querySelectorAll('[data-plane]').forEach(cb => {
        if (cb.checked) activePlanes.add(cb.dataset.plane);
      });
      cy.edges().forEach(e => {
        if (activePlanes.has(e.data('plane'))) e.show(); else e.hide();
      });

      // Node types
      const activeTypes = new Set();
      document.querySelectorAll('[data-node-type]').forEach(cb => {
        if (cb.checked) activeTypes.add(cb.dataset.nodeType);
      });
      cy.nodes().forEach(n => {
        if (activeTypes.has(n.data('type'))) n.show(); else n.hide();
      });

      // Hide orphans if toggle is off
      if (!document.getElementById('toggle-orphans').checked) {
        cy.nodes().forEach(n => {
          if (n.visible() && n.connectedEdges().filter(e => e.visible()).length === 0) n.hide();
        });
      }

      updateStats();
    }

    // -- Search --
    document.getElementById('search').addEventListener('input', (e) => {
      const q = e.target.value.toLowerCase().trim();
      cy.nodes().removeClass('highlighted');
      clearDimming();
      if (q.length < 2) return;

      const matches = cy.nodes().filter(n =>
        n.data('id').toLowerCase().includes(q) ||
        n.data('label').toLowerCase().includes(q)
      );
      matches.addClass('highlighted');

      if (matches.length > 0 && matches.length <= 20) {
        // Dim everything else
        cy.elements().addClass('dimmed');
        matches.removeClass('dimmed');
        matches.connectedEdges().removeClass('dimmed');
        matches.connectedEdges().connectedNodes().removeClass('dimmed');
      }

      if (matches.length === 1) {
        cy.animate({ center: { eles: matches }, zoom: 2.5 }, { duration: 300 });
      } else if (matches.length > 1 && matches.length <= 20) {
        cy.animate({ fit: { eles: matches, padding: 60 } }, { duration: 300 });
      }
    });

    // -- Node tap --
    function onNodeTap(evt) {
      const node = evt.target;
      clearDimming();

      // Highlight neighborhood
      const neighborhood = node.neighborhood();
      cy.elements().addClass('dimmed');
      node.removeClass('dimmed');
      neighborhood.removeClass('dimmed');
      neighborhood.nodes().addClass('neighbor');

      // Detail panel
      const d = document.getElementById('detail');
      d.className = '';
      const type = node.data('type');
      const badgeColor = NODE_COLORS[type] || '#475569';

      let html = `<h2>${node.data('id')}</h2>`;
      html += `<span class="badge" style="background:${badgeColor}33;color:${badgeColor}">${type}</span>`;
      html += `<table><tr><td>Label</td><td>${node.data('label')}</td></tr>`;

      // Extra props
      const skip = new Set(['id', 'label', 'type']);
      const data = node.data();
      Object.entries(data).forEach(([k, v]) => {
        if (skip.has(k) || v === undefined || v === null) return;
        if (typeof v === 'object') v = JSON.stringify(v);
        html += `<tr><td>${k}</td><td>${v}</td></tr>`;
      });
      html += '</table>';

      // Connected edges grouped by plane
      const connected = node.connectedEdges().filter(e => e.visible());
      if (connected.length > 0) {
        const byPlane = {};
        connected.forEach(e => {
          const plane = e.data('plane');
          if (!byPlane[plane]) byPlane[plane] = [];
          const other = e.source().id() === node.id() ? e.target() : e.source();
          byPlane[plane].push({
            predicate: e.data('predicate'),
            otherId: other.id(),
            otherLabel: other.data('label'),
            direction: e.source().id() === node.id() ? 'out' : 'in',
            confidence: e.data('confidence'),
            meta: e.data('meta'),
          });
        });

        Object.entries(byPlane).forEach(([plane, edges]) => {
          html += `<div class="section-label">${plane} (${edges.length})</div><ul>`;
          edges.forEach(e => {
            const arrow = e.direction === 'out' ? '&rarr;' : '&larr;';
            const conf = e.confidence ? ` <span style="color:#64748b">(${(e.confidence*100).toFixed(0)}%)</span>` : '';
            const cov = e.meta?.coverage ? ` <span style="color:#64748b">[${e.meta.coverage}]</span>` : '';
            html += `<li data-node-id="${e.otherId}">${arrow} <b>${e.predicate}</b> ${e.otherId}${conf}${cov}</li>`;
          });
          html += '</ul>';
        });
      }

      d.innerHTML = html;

      // Click handlers for linked nodes
      d.querySelectorAll('[data-node-id]').forEach(li => {
        li.addEventListener('click', () => {
          const target = cy.getElementById(li.dataset.nodeId);
          if (target.length > 0) {
            cy.animate({ center: { eles: target }, zoom: 2.5 }, { duration: 300 });
            target.emit('tap');
          }
        });
      });
    }

    // -- Edge tap --
    function onEdgeTap(evt) {
      const edge = evt.target;
      const d = document.getElementById('detail');
      d.className = '';
      const plane = edge.data('plane');
      const planeColor = PLANE_COLORS[plane] || '#475569';

      let html = `<h2>${edge.data('source')} &rarr; ${edge.data('target')}</h2>`;
      html += `<span class="badge" style="background:${planeColor}33;color:${planeColor}">${plane}</span>`;
      html += `<table>`;
      html += `<tr><td>Predicate</td><td><b>${edge.data('predicate')}</b></td></tr>`;
      html += `<tr><td>Confidence</td><td>${(edge.data('confidence')*100).toFixed(0)}%</td></tr>`;
      const meta = edge.data('meta');
      if (meta && Object.keys(meta).length > 0) {
        Object.entries(meta).forEach(([k, v]) => {
          html += `<tr><td>${k}</td><td>${v}</td></tr>`;
        });
      }
      html += '</table>';

      html += `<div class="section-label">Endpoints</div><ul>`;
      html += `<li data-node-id="${edge.data('source')}">${edge.data('source')}</li>`;
      html += `<li data-node-id="${edge.data('target')}">${edge.data('target')}</li>`;
      html += '</ul>';

      d.innerHTML = html;

      d.querySelectorAll('[data-node-id]').forEach(li => {
        li.addEventListener('click', () => {
          const target = cy.getElementById(li.dataset.nodeId);
          if (target.length > 0) {
            cy.animate({ center: { eles: target }, zoom: 2.5 }, { duration: 300 });
            target.emit('tap');
          }
        });
      });
    }

    // -- Helpers --
    function clearSelection() {
      clearDimming();
      const d = document.getElementById('detail');
      d.className = 'empty';
      d.innerHTML = '<span>Click a node or edge to inspect</span>';
    }

    function clearDimming() {
      cy.elements().removeClass('dimmed').removeClass('highlighted').removeClass('neighbor');
    }

    function updateStats() {
      const vn = cy.nodes().filter(n => n.visible()).length;
      const ve = cy.edges().filter(e => e.visible()).length;
      const tn = graphData.nodes.length;
      const te = graphData.edges.length;
      document.getElementById('stats').textContent =
        `${tn} nodes, ${te} edges | Visible: ${vn} nodes, ${ve} edges`;
    }

    // -- Toolbar --
    document.getElementById('btn-fit').addEventListener('click', () => cy.fit(null, 40));
    document.getElementById('btn-reset').addEventListener('click', () => {
      clearSelection();
      document.getElementById('search').value = '';
      document.querySelectorAll('aside input[type="checkbox"]').forEach(cb => cb.checked = true);
      applyFilters();
      cy.fit(null, 40);
    });
    document.getElementById('btn-png').addEventListener('click', () => {
      const png = cy.png({ bg: '#0f172a', full: true, scale: 2 });
      const a = document.createElement('a');
      a.href = png; a.download = 'grc-knowledge-graph.png'; a.click();
    });

    // Layout
    document.getElementById('layout-select').addEventListener('change', (e) => {
      const name = e.target.value;
      const opts = { name, animate: true, animationDuration: 500, nodeDimensionsIncludeLabels: true };
      if (name === 'cose') { opts.animate = false; opts.nodeRepulsion = () => 12000; opts.idealEdgeLength = () => 80; }
      if (name === 'breadthfirst') { opts.directed = true; opts.spacingFactor = 0.9; }
      if (name === 'concentric') { opts.concentric = (n) => n.degree(); opts.levelWidth = () => 3; }
      cy.layout(opts).run();
    });

    // Toggles
    document.getElementById('toggle-labels').addEventListener('change', (e) => {
      cy.style().selector('node').style('label', e.target.checked ? 'data(id)' : '').update();
    });
    document.getElementById('toggle-orphans').addEventListener('change', applyFilters);

    // -- Chat module --
    const chatDrawer = document.getElementById('chat-drawer');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    const chatStatus = document.getElementById('chat-status');
    const chatToggleIcon = document.getElementById('chat-toggle-icon');
    const btnChat = document.getElementById('btn-chat');

    let chatHistory = []; // {role, content} for API
    let chatOpen = false;
    let chatStreaming = false;
    let selectedNodeId = null;

    // Track selected node
    function getSelectedNodeId() {
      const sel = cy?.elements('node:selected');
      return (sel && sel.length > 0) ? sel[0].id() : null;
    }

    // Toggle drawer
    function toggleChat() {
      chatOpen = !chatOpen;
      chatDrawer.classList.toggle('collapsed', !chatOpen);
      btnChat.classList.toggle('active', chatOpen);
      chatToggleIcon.innerHTML = chatOpen ? '&#9660;' : '&#9650;';
      if (chatOpen) chatInput.focus();
    }

    btnChat.addEventListener('click', toggleChat);
    document.getElementById('chat-header').addEventListener('click', toggleChat);

    // Auto-resize textarea
    chatInput.addEventListener('input', () => {
      chatInput.style.height = 'auto';
      chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
    });

    // Send on Enter (Shift+Enter for newline)
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    chatSend.addEventListener('click', sendMessage);

    async function sendMessage() {
      const text = chatInput.value.trim();
      if (!text || chatStreaming) return;

      // Append user message
      chatHistory.push({ role: 'user', content: text });
      appendChatBubble('user', text);
      chatInput.value = '';
      chatInput.style.height = 'auto';

      chatStreaming = true;
      chatSend.disabled = true;
      chatStatus.textContent = 'Thinking...';

      // Create assistant bubble for streaming
      const assistantBubble = appendChatBubble('assistant', '');
      let fullResponse = '';

      try {
        const res = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            messages: chatHistory,
            selectedNode: getSelectedNodeId(),
          }),
        });

        if (!res.ok) {
          const err = await res.json().catch(() => ({ error: `HTTP ${res.status}` }));
          throw new Error(err.error || `HTTP ${res.status}`);
        }

        // Read SSE stream
        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop(); // keep incomplete line in buffer

          for (const line of lines) {
            if (!line.startsWith('data: ')) continue;
            const data = JSON.parse(line.slice(6));

            if (data.type === 'delta') {
              fullResponse += data.text;
              renderAssistantBubble(assistantBubble, fullResponse);
            } else if (data.type === 'error') {
              throw new Error(data.text);
            }
          }
        }

        // Save assistant response to history
        chatHistory.push({ role: 'assistant', content: fullResponse });
      } catch (err) {
        if (!fullResponse) {
          assistantBubble.remove();
        }
        appendChatBubble('error', err.message);
        // Remove the user message from history if we got no response
        if (!fullResponse) chatHistory.pop();
      } finally {
        chatStreaming = false;
        chatSend.disabled = false;
        chatStatus.textContent = '';
      }
    }

    function appendChatBubble(role, text) {
      const div = document.createElement('div');
      div.className = `chat-msg ${role}`;
      if (role === 'user') {
        div.textContent = text;
      } else if (role === 'error') {
        div.textContent = text;
      }
      chatMessages.appendChild(div);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      return div;
    }

    function renderAssistantBubble(el, markdown) {
      // Render markdown to HTML
      let html = marked.parse(markdown);
      // Make node IDs clickable â€” match patterns like NIST-AC-2, SOC2-CC6.1, FEDRAMP-MODERATE, etc.
      html = html.replace(/\b([A-Z][A-Z0-9]*(?:-[A-Za-z0-9.]+)+)\b/g, (match) => {
        // Only link if the ID exists in the graph
        if (graphData && graphData.nodes.some(n => n.id === match)) {
          return `<a class="node-link" data-node-id="${match}">${match}</a>`;
        }
        return match;
      });
      el.innerHTML = html;

      // Bind node link clicks
      el.querySelectorAll('.node-link').forEach(a => {
        a.addEventListener('click', (e) => {
          e.preventDefault();
          const nodeId = a.dataset.nodeId;
          const target = cy.getElementById(nodeId);
          if (target.length > 0) {
            cy.animate({ center: { eles: target }, zoom: 2.5 }, { duration: 300 });
            target.emit('tap');
          }
        });
      });

      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Run
    init();
  </script>
</body>
</html>
