<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GRC Knowledge Graph Viewer</title>
<script src="https://unpkg.com/cytoscape@3.30.4/dist/cytoscape.min.js"></script>
<script src="https://unpkg.com/marked@15.0.4/marked.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: #0f172a; color: #e2e8f0; height: 100vh;
    display: grid; grid-template-rows: auto 1fr auto;
    grid-template-columns: 240px 1fr 320px;
    overflow: hidden;
  }

  /* Header */
  header {
    grid-column: 1 / -1; padding: 10px 16px;
    background: #1e293b; border-bottom: 1px solid #334155;
    display: flex; align-items: center; gap: 12px;
  }
  header h1 { font-size: 16px; font-weight: 600; white-space: nowrap; }
  header .stats { font-size: 12px; color: #94a3b8; white-space: nowrap; }
  header input[type="text"] {
    flex: 1; max-width: 320px; padding: 6px 10px;
    background: #0f172a; border: 1px solid #475569; border-radius: 6px;
    color: #e2e8f0; font-size: 13px; outline: none;
  }
  header input[type="text"]:focus { border-color: #3b82f6; }
  header .actions { display: flex; gap: 6px; margin-left: auto; }
  header button {
    padding: 5px 10px; background: #334155; border: 1px solid #475569;
    border-radius: 5px; color: #e2e8f0; font-size: 12px; cursor: pointer;
  }
  header button:hover { background: #475569; }
  header button.active { background: #3b82f6; border-color: #3b82f6; }

  /* Sidebar */
  aside {
    background: #1e293b; border-right: 1px solid #334155;
    padding: 12px; overflow-y: auto; font-size: 13px;
  }
  aside h3 { font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; color: #64748b; margin: 12px 0 6px; }
  aside h3:first-child { margin-top: 0; }
  aside label {
    display: flex; align-items: center; gap: 6px; padding: 3px 0; cursor: pointer;
  }
  aside label input { cursor: pointer; }
  .color-dot {
    display: inline-block; width: 10px; height: 10px; border-radius: 50%;
    flex-shrink: 0;
  }
  .plane-line {
    display: inline-block; width: 16px; height: 3px; flex-shrink: 0; border-radius: 1px;
  }
  .filter-count { color: #64748b; font-size: 11px; margin-left: auto; }
  aside select {
    width: 100%; padding: 5px 6px; background: #0f172a; border: 1px solid #475569;
    border-radius: 5px; color: #e2e8f0; font-size: 12px; margin-top: 4px;
  }

  /* Quick explore */
  .quick-btn {
    display: block; width: 100%; padding: 5px 8px; margin: 3px 0;
    background: #0f172a; border: 1px solid #475569; border-radius: 5px;
    color: #e2e8f0; font-size: 12px; cursor: pointer; text-align: left;
  }
  .quick-btn:hover { background: #334155; border-color: #3b82f6; }
  .quick-btn.active { background: #1e3a5f; border-color: #3b82f6; }

  /* Canvas */
  #cy { background: #0f172a; position: relative; }

  /* Detail panel */
  #detail {
    background: #1e293b; border-left: 1px solid #334155;
    padding: 12px; overflow-y: auto; font-size: 13px;
  }
  #detail.empty { display: flex; align-items: center; justify-content: center; color: #64748b; }
  #detail h2 { font-size: 14px; font-weight: 600; margin-bottom: 8px; word-break: break-all; }
  #detail .badge {
    display: inline-block; padding: 2px 8px; border-radius: 10px;
    font-size: 11px; font-weight: 500; margin-bottom: 10px;
  }
  #detail table { width: 100%; border-collapse: collapse; }
  #detail td { padding: 4px 0; vertical-align: top; }
  #detail td:first-child { color: #94a3b8; width: 110px; padding-right: 8px; }
  #detail td:last-child { word-break: break-word; }
  #detail .section-label {
    font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px;
    color: #64748b; margin: 14px 0 6px; border-top: 1px solid #334155; padding-top: 10px;
    display: flex; align-items: center; gap: 6px;
  }
  #detail .section-label .pred-dot {
    display: inline-block; width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
  }
  #detail ul { list-style: none; padding: 0; }
  #detail ul li {
    padding: 3px 0; cursor: pointer; color: #93c5fd;
  }
  #detail ul li:hover { color: #60a5fa; text-decoration: underline; }
  #detail .confidence-bar {
    display: inline-block; width: 40px; height: 4px; background: #334155;
    border-radius: 2px; margin-left: 4px; vertical-align: middle;
  }
  #detail .confidence-bar .fill {
    height: 100%; border-radius: 2px; background: #10b981;
  }

  /* Stats bar */
  .stats-breakdown {
    display: flex; gap: 6px; flex-wrap: wrap; margin-top: 6px;
  }
  .stats-breakdown .stat-chip {
    font-size: 10px; padding: 2px 6px; border-radius: 4px;
    background: #334155; color: #94a3b8;
  }

  /* Chat drawer */
  #chat-drawer {
    grid-column: 1 / -1;
    background: #1e293b;
    border-top: 1px solid #334155;
    display: flex; flex-direction: column;
    max-height: 50vh;
    transition: max-height 0.3s ease;
  }
  #chat-drawer.collapsed {
    max-height: 0; overflow: hidden; border-top: none;
  }
  #chat-header {
    display: flex; align-items: center; gap: 10px;
    padding: 8px 16px;
    background: #1e293b; border-bottom: 1px solid #334155;
    cursor: pointer; user-select: none; flex-shrink: 0;
  }
  #chat-header h3 { font-size: 13px; font-weight: 600; flex: 1; }
  #chat-header .chat-toggle { font-size: 18px; color: #94a3b8; }
  #chat-header .chat-status { font-size: 11px; color: #64748b; }
  #chat-messages {
    flex: 1; overflow-y: auto; padding: 14px 16px;
    display: flex; flex-direction: column; gap: 12px;
    min-height: 0;
  }
  .chat-msg {
    max-width: 85%; padding: 10px 14px; border-radius: 10px;
    font-size: 13px; line-height: 1.6; overflow-wrap: break-word; word-break: break-word;
  }
  .chat-msg.user {
    align-self: flex-end; background: #3b82f6; color: #fff;
    border-bottom-right-radius: 3px; white-space: pre-wrap;
  }
  .chat-msg.assistant {
    align-self: flex-start; background: #334155; color: #e2e8f0;
    border-bottom-left-radius: 3px; max-width: 92%;
  }
  .chat-msg.assistant > *:first-child { margin-top: 0; }
  .chat-msg.assistant > *:last-child { margin-bottom: 0; }
  .chat-msg.assistant p { margin: 0 0 10px; }
  .chat-msg.assistant h1, .chat-msg.assistant h2, .chat-msg.assistant h3,
  .chat-msg.assistant h4, .chat-msg.assistant h5, .chat-msg.assistant h6 {
    margin: 14px 0 6px; font-weight: 600; color: #f1f5f9; line-height: 1.3;
  }
  .chat-msg.assistant h1 { font-size: 17px; }
  .chat-msg.assistant h2 { font-size: 15px; }
  .chat-msg.assistant h3 { font-size: 14px; }
  .chat-msg.assistant h4, .chat-msg.assistant h5, .chat-msg.assistant h6 { font-size: 13px; }
  .chat-msg.assistant ul, .chat-msg.assistant ol {
    margin: 6px 0 10px; padding-left: 22px;
  }
  .chat-msg.assistant ul { list-style-type: disc; }
  .chat-msg.assistant ol { list-style-type: decimal; }
  .chat-msg.assistant ul ul { list-style-type: circle; margin: 2px 0; }
  .chat-msg.assistant li { margin: 3px 0; }
  .chat-msg.assistant strong { font-weight: 600; color: #f1f5f9; }
  .chat-msg.assistant em { font-style: italic; color: #cbd5e1; }
  .chat-msg.assistant code {
    background: #1e293b; padding: 2px 5px; border-radius: 3px;
    font-size: 12px; font-family: 'Consolas', 'Monaco', monospace;
  }
  .chat-msg.assistant pre {
    background: #0f172a; padding: 10px 12px; border-radius: 6px;
    overflow-x: auto; margin: 8px 0; border: 1px solid #475569;
  }
  .chat-msg.assistant pre code { background: none; padding: 0; font-size: 12px; }
  .chat-msg.assistant blockquote {
    border-left: 3px solid #3b82f6; padding: 4px 12px; margin: 8px 0;
    color: #94a3b8; background: #1e293b; border-radius: 0 4px 4px 0;
  }
  .chat-msg.assistant hr {
    border: none; border-top: 1px solid #475569; margin: 12px 0;
  }
  .chat-msg.assistant table {
    border-collapse: collapse; margin: 8px 0; font-size: 12px; width: 100%;
  }
  .chat-msg.assistant th, .chat-msg.assistant td {
    border: 1px solid #475569; padding: 5px 10px; text-align: left;
  }
  .chat-msg.assistant th { background: #1e293b; font-weight: 600; color: #f1f5f9; }
  .chat-msg.assistant a.node-link {
    color: #93c5fd; cursor: pointer; text-decoration: underline;
    text-decoration-style: dotted;
  }
  .chat-msg.assistant a.node-link:hover { color: #60a5fa; text-decoration-style: solid; }
  .chat-msg.error {
    align-self: center; background: #7f1d1d; color: #fca5a5;
    font-size: 12px; border-radius: 6px;
  }
  #chat-input-bar {
    display: flex; gap: 8px; padding: 8px 16px;
    border-top: 1px solid #334155; flex-shrink: 0;
  }
  #chat-input {
    flex: 1; padding: 8px 12px; background: #0f172a; border: 1px solid #475569;
    border-radius: 6px; color: #e2e8f0; font-size: 13px; outline: none;
    font-family: inherit; resize: none;
  }
  #chat-input:focus { border-color: #3b82f6; }
  #chat-send {
    padding: 8px 16px; background: #3b82f6; border: none;
    border-radius: 6px; color: #fff; font-size: 13px; cursor: pointer;
    font-weight: 500; white-space: nowrap;
  }
  #chat-send:hover { background: #2563eb; }
  #chat-send:disabled { background: #475569; cursor: not-allowed; }
</style>
</head>
<body>
  <header>
    <h1>GRC Knowledge Graph</h1>
    <span class="stats" id="stats">Loading...</span>
    <input type="text" id="search" placeholder="Search nodes (e.g. AC-2, GDPR-ART32, N171-3.1)..." />
    <div class="actions">
      <button id="btn-fit" title="Fit graph to view">Fit</button>
      <button id="btn-reset" title="Reset view and clear selection">Reset</button>
      <button id="btn-png" title="Export as PNG">PNG</button>
      <button id="btn-chat" title="Toggle chat with Claude">Chat</button>
    </div>
  </header>

  <aside>
    <h3>Focus Framework</h3>
    <select id="framework-select">
      <option value="">All Frameworks</option>
    </select>

    <h3>Edge Predicates</h3>
    <div id="predicate-filters"></div>

    <h3>Node Types</h3>
    <div id="type-filters"></div>

    <h3>Layout</h3>
    <select id="layout-select">
      <option value="cose">Force-Directed (cose)</option>
      <option value="breadthfirst">Hierarchy (breadthfirst)</option>
      <option value="concentric">Concentric</option>
      <option value="circle">Circle</option>
    </select>

    <h3>Visibility</h3>
    <label>
      <input type="checkbox" id="toggle-labels" checked />
      Show labels
    </label>
    <label>
      <input type="checkbox" id="toggle-orphans" />
      Show orphaned nodes
    </label>
  </aside>

  <div id="cy"></div>

  <div id="detail" class="empty">
    <span>Click a node or edge to inspect</span>
  </div>

  <div id="chat-drawer" class="collapsed">
    <div id="chat-header">
      <h3>Chat with Claude</h3>
      <span class="chat-status" id="chat-status"></span>
      <span class="chat-toggle" id="chat-toggle-icon">&#9650;</span>
    </div>
    <div id="chat-messages"></div>
    <div id="chat-input-bar">
      <textarea id="chat-input" rows="1" placeholder="Ask about the graph (e.g., &quot;What controls are in FedRAMP Moderate?&quot;)"></textarea>
      <button id="chat-send">Send</button>
    </div>
  </div>

  <script>
    // ── Config ──────────────────────────────────────────────────────────
    const NODE_COLORS = {
      Framework:     '#3b82f6',
      ControlFamily: '#8b5cf6',
      Control:       '#10b981',
      Baseline:      '#f59e0b',
      ServiceModel:  '#ef4444',
      EvidenceType:  '#06b6d4',
      DocumentType:  '#6b7280',
    };
    const NODE_SHAPES = {
      Framework:     'diamond',
      ControlFamily: 'round-rectangle',
      Control:       'ellipse',
      Baseline:      'pentagon',
      ServiceModel:  'hexagon',
      EvidenceType:  'rectangle',
      DocumentType:  'rectangle',
    };
    const NODE_SIZES = {
      Framework: 40, ControlFamily: 28, Control: 16,
      Baseline: 26, ServiceModel: 28, EvidenceType: 22, DocumentType: 22,
    };

    // Per-predicate styling
    const PREDICATE_COLORS = {
      CONTAINS:          '#6b7280',
      ASSIGNED_TO:       '#f59e0b',
      MAPS_TO:           '#3b82f6',
      REQUIRES_EVIDENCE: '#06b6d4',
      RESPONSIBILITY_OF: '#ef4444',
      DOCUMENTED_IN:     '#a78bfa',
      INHERITS_FROM:     '#f97316',
      PART_OF:           '#6b7280',
      SUPERSEDES:        '#64748b',
    };
    const PREDICATE_STYLES = {
      CONTAINS:          'solid',
      ASSIGNED_TO:       'solid',
      MAPS_TO:           'dashed',
      REQUIRES_EVIDENCE: 'dotted',
      RESPONSIBILITY_OF: 'solid',
      DOCUMENTED_IN:     'dotted',
      INHERITS_FROM:     'solid',
      PART_OF:           'solid',
      SUPERSEDES:        'dashed',
    };

    // Which predicates are on by default (hierarchy + cross-framework)
    const DEFAULT_ON_PREDICATES = new Set(['CONTAINS', 'MAPS_TO']);

    let cy, graphData;
    let focusedFramework = '';

    // ── Init ────────────────────────────────────────────────────────────
    async function init() {
      const res = await fetch('/api/graph');
      graphData = await res.json();

      const elements = [];

      // Nodes
      graphData.nodes.forEach(n => {
        elements.push({
          group: 'nodes',
          data: { id: n.id, label: n.label, type: n.type, ...n.props },
          classes: n.type,
        });
      });

      // Edges — add predicate as a class
      graphData.edges.forEach((e, i) => {
        elements.push({
          group: 'edges',
          data: {
            id: `e${i}`, source: e.source, target: e.target,
            predicate: e.predicate, plane: e.plane,
            confidence: e.confidence, meta: e.meta,
          },
          classes: `${e.plane} pred-${e.predicate}`,
        });
      });

      // Build stylesheet
      const style = [
        // Default node
        { selector: 'node', style: {
          'label': 'data(id)', 'font-size': 7, 'color': '#cbd5e1',
          'text-valign': 'bottom', 'text-margin-y': 3,
          'min-zoomed-font-size': 5,
          'text-max-width': 80, 'text-wrap': 'ellipsis',
        }},
        // Default edge
        { selector: 'edge', style: {
          'width': 1, 'curve-style': 'bezier',
          'target-arrow-shape': 'triangle', 'arrow-scale': 0.5,
          'opacity': 0.5,
        }},
        { selector: 'node.highlighted', style: {
          'border-width': 3, 'border-color': '#fbbf24', 'z-index': 100,
        }},
        { selector: 'node:selected', style: {
          'border-width': 3, 'border-color': '#f472b6',
        }},
        { selector: 'edge:selected', style: {
          'width': 3, 'opacity': 1, 'z-index': 100,
        }},
        { selector: 'node.neighbor', style: {
          'border-width': 2, 'border-color': '#fbbf24', 'opacity': 1,
        }},
        { selector: 'node.dimmed', style: { 'opacity': 0.12 }},
        { selector: 'edge.dimmed', style: { 'opacity': 0.03 }},
        { selector: 'node.faded', style: { 'opacity': 0.08 }},
        { selector: 'edge.faded', style: { 'opacity': 0.02 }},
      ];

      // Node type styles
      Object.entries(NODE_COLORS).forEach(([type, color]) => {
        style.push({ selector: `node.${type}`, style: {
          'background-color': color,
          'shape': NODE_SHAPES[type] || 'ellipse',
          'width': NODE_SIZES[type] || 20,
          'height': NODE_SIZES[type] || 20,
        }});
      });

      // Per-predicate edge styles
      Object.entries(PREDICATE_COLORS).forEach(([pred, color]) => {
        style.push({ selector: `edge.pred-${pred}`, style: {
          'line-color': color,
          'target-arrow-color': color,
          'line-style': PREDICATE_STYLES[pred] || 'solid',
        }});
      });

      cy = cytoscape({
        container: document.getElementById('cy'),
        elements,
        style,
        layout: {
          name: 'cose', animate: false,
          nodeRepulsion: () => 20000,
          idealEdgeLength: () => 100,
          nodeOverlap: 20,
          nodeDimensionsIncludeLabels: true,
          gravity: 0.3,
          numIter: 500,
        },
        minZoom: 0.05, maxZoom: 6,
        wheelSensitivity: 0.25,
        pixelRatio: 1,
        textureOnViewport: true,
      });

      // Events
      cy.on('tap', 'node', onNodeTap);
      cy.on('tap', 'edge', onEdgeTap);
      cy.on('tap', (evt) => { if (evt.target === cy) clearSelection(); });

      buildFilters();
      applyFilters();
      updateStats();
    }

    // ── Filters ─────────────────────────────────────────────────────────
    function buildFilters() {
      // Framework selector
      const fwSelect = document.getElementById('framework-select');
      const frameworks = graphData.nodes
        .filter(n => n.type === 'Framework')
        .sort((a, b) => a.label.localeCompare(b.label));
      frameworks.forEach(fw => {
        const opt = document.createElement('option');
        opt.value = fw.id; opt.textContent = fw.label;
        fwSelect.appendChild(opt);
      });

      // Predicate filters with counts
      const predDiv = document.getElementById('predicate-filters');
      const predCounts = {};
      graphData.edges.forEach(e => {
        predCounts[e.predicate] = (predCounts[e.predicate] || 0) + 1;
      });

      // Order: most important first
      const predOrder = ['CONTAINS', 'MAPS_TO', 'ASSIGNED_TO', 'REQUIRES_EVIDENCE',
                         'RESPONSIBILITY_OF', 'DOCUMENTED_IN', 'INHERITS_FROM', 'PART_OF', 'SUPERSEDES'];
      const usedPreds = predOrder.filter(p => predCounts[p]);

      usedPreds.forEach(pred => {
        const label = document.createElement('label');
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = DEFAULT_ON_PREDICATES.has(pred);
        cb.dataset.predicate = pred;
        cb.addEventListener('change', applyFilters);

        const dot = document.createElement('span');
        dot.className = 'color-dot';
        dot.style.background = PREDICATE_COLORS[pred] || '#475569';

        const count = document.createElement('span');
        count.className = 'filter-count';
        count.textContent = predCounts[pred] || 0;

        label.append(cb, dot, ` ${pred} `, count);
        predDiv.appendChild(label);
      });

      // Node type filters with counts
      const typeDiv = document.getElementById('type-filters');
      const typeCounts = {};
      graphData.nodes.forEach(n => {
        typeCounts[n.type] = (typeCounts[n.type] || 0) + 1;
      });

      Object.keys(NODE_COLORS).forEach(type => {
        const label = document.createElement('label');
        const cb = document.createElement('input');
        cb.type = 'checkbox'; cb.checked = true; cb.dataset.nodeType = type;
        cb.addEventListener('change', applyFilters);

        const dot = document.createElement('span');
        dot.className = 'color-dot'; dot.style.background = NODE_COLORS[type];

        const count = document.createElement('span');
        count.className = 'filter-count';
        count.textContent = typeCounts[type] || 0;

        label.append(cb, dot, ` ${type} `, count);
        typeDiv.appendChild(label);
      });
    }

    function applyFilters() {
      // Active predicates
      const activePredicates = new Set();
      document.querySelectorAll('[data-predicate]').forEach(cb => {
        if (cb.checked) activePredicates.add(cb.dataset.predicate);
      });

      cy.edges().forEach(e => {
        if (activePredicates.has(e.data('predicate'))) e.show(); else e.hide();
      });

      // Node types
      const activeTypes = new Set();
      document.querySelectorAll('[data-node-type]').forEach(cb => {
        if (cb.checked) activeTypes.add(cb.dataset.nodeType);
      });
      cy.nodes().forEach(n => {
        if (activeTypes.has(n.data('type'))) n.show(); else n.hide();
      });

      // Framework focus
      if (focusedFramework) {
        applyFrameworkFocus(focusedFramework);
      }

      // Hide orphans if toggle is off
      if (!document.getElementById('toggle-orphans').checked) {
        cy.nodes().forEach(n => {
          if (n.visible() && n.connectedEdges().filter(e => e.visible()).length === 0) n.hide();
        });
      }

      updateStats();
    }

    function applyFrameworkFocus(frameworkId) {
      if (!frameworkId) {
        cy.elements().removeClass('faded');
        return;
      }

      // Find all nodes connected to this framework via CONTAINS (hierarchy)
      const fwNode = cy.getElementById(frameworkId);
      if (fwNode.length === 0) return;

      // BFS through CONTAINS to find all descendants
      const inScope = cy.collection();
      inScope.merge(fwNode);

      let frontier = fwNode;
      for (let depth = 0; depth < 4; depth++) {
        const nextEdges = frontier.connectedEdges().filter(e =>
          e.data('predicate') === 'CONTAINS' && e.source().id() !== e.target().id()
        );
        const nextNodes = nextEdges.connectedNodes().difference(inScope);
        if (nextNodes.length === 0) break;
        inScope.merge(nextEdges);
        inScope.merge(nextNodes);
        frontier = nextNodes;
      }

      // Also include nodes connected via visible edges from in-scope controls
      const controls = inScope.nodes().filter(n => n.data('type') === 'Control');
      const crossEdges = controls.connectedEdges().filter(e => e.visible());
      const crossNodes = crossEdges.connectedNodes();
      inScope.merge(crossEdges);
      inScope.merge(crossNodes);

      // Fade everything not in scope
      cy.elements().addClass('faded');
      inScope.removeClass('faded');
    }

    // Framework selector
    document.getElementById('framework-select').addEventListener('change', (e) => {
      focusedFramework = e.target.value;
      cy.elements().removeClass('faded');
      if (focusedFramework) {
        applyFrameworkFocus(focusedFramework);
      }
      updateStats();
    });

    // ── Search ──────────────────────────────────────────────────────────
    document.getElementById('search').addEventListener('input', (e) => {
      const q = e.target.value.toLowerCase().trim();
      cy.nodes().removeClass('highlighted');
      clearDimming();
      if (q.length < 2) return;

      const matches = cy.nodes().filter(n =>
        n.data('id').toLowerCase().includes(q) ||
        n.data('label').toLowerCase().includes(q)
      );
      matches.addClass('highlighted');

      if (matches.length > 0 && matches.length <= 30) {
        cy.elements().addClass('dimmed');
        matches.removeClass('dimmed');
        matches.connectedEdges().filter(e => e.visible()).removeClass('dimmed');
        matches.connectedEdges().filter(e => e.visible()).connectedNodes().removeClass('dimmed');
      }

      if (matches.length === 1) {
        cy.animate({ center: { eles: matches }, zoom: 2.5 }, { duration: 300 });
      } else if (matches.length > 1 && matches.length <= 30) {
        cy.animate({ fit: { eles: matches, padding: 60 } }, { duration: 300 });
      }
    });

    // ── Node tap ────────────────────────────────────────────────────────
    function onNodeTap(evt) {
      const node = evt.target;
      clearDimming();

      // Highlight neighborhood
      const neighborhood = node.neighborhood();
      cy.elements().addClass('dimmed');
      node.removeClass('dimmed');
      neighborhood.removeClass('dimmed');
      neighborhood.nodes().addClass('neighbor');

      // Detail panel
      const d = document.getElementById('detail');
      d.className = '';
      const type = node.data('type');
      const badgeColor = NODE_COLORS[type] || '#475569';

      let html = `<h2>${node.data('id')}</h2>`;
      html += `<span class="badge" style="background:${badgeColor}33;color:${badgeColor}">${type}</span>`;
      html += `<table><tr><td>Label</td><td>${node.data('label')}</td></tr>`;

      // Extra props
      const skip = new Set(['id', 'label', 'type']);
      const data = node.data();
      Object.entries(data).forEach(([k, v]) => {
        if (skip.has(k) || v === undefined || v === null) return;
        if (typeof v === 'object') v = JSON.stringify(v);
        html += `<tr><td>${k}</td><td>${v}</td></tr>`;
      });
      html += '</table>';

      // Connected edges grouped by predicate
      const connected = node.connectedEdges().filter(e => e.visible());
      if (connected.length > 0) {
        const byPredicate = {};
        connected.forEach(e => {
          const pred = e.data('predicate');
          if (!byPredicate[pred]) byPredicate[pred] = [];
          const other = e.source().id() === node.id() ? e.target() : e.source();
          byPredicate[pred].push({
            predicate: pred,
            otherId: other.id(),
            otherLabel: other.data('label'),
            direction: e.source().id() === node.id() ? 'out' : 'in',
            confidence: e.data('confidence'),
            meta: e.data('meta'),
          });
        });

        // Order predicates for readability
        const predOrder = ['CONTAINS', 'ASSIGNED_TO', 'MAPS_TO', 'REQUIRES_EVIDENCE',
                           'RESPONSIBILITY_OF', 'DOCUMENTED_IN', 'INHERITS_FROM', 'PART_OF'];
        const sortedPreds = Object.keys(byPredicate).sort((a, b) => {
          const ai = predOrder.indexOf(a), bi = predOrder.indexOf(b);
          return (ai === -1 ? 99 : ai) - (bi === -1 ? 99 : bi);
        });

        sortedPreds.forEach(pred => {
          const edges = byPredicate[pred];
          const predColor = PREDICATE_COLORS[pred] || '#475569';
          html += `<div class="section-label"><span class="pred-dot" style="background:${predColor}"></span>${pred} (${edges.length})</div><ul>`;
          edges.forEach(e => {
            const arrow = e.direction === 'out' ? '&rarr;' : '&larr;';
            let confHtml = '';
            if (e.confidence) {
              const pct = (e.confidence * 100).toFixed(0);
              confHtml = ` <span class="confidence-bar"><span class="fill" style="width:${pct}%"></span></span>`;
            }
            const cov = e.meta?.coverage ? ` <span style="color:#64748b;font-size:11px">[${e.meta.coverage}]</span>` : '';
            const resp = e.meta?.responsibility_type ? ` <span style="color:#64748b;font-size:11px">[${e.meta.responsibility_type}]</span>` : '';
            html += `<li data-node-id="${e.otherId}">${arrow} ${e.otherId}${confHtml}${cov}${resp}</li>`;
          });
          html += '</ul>';
        });
      }

      d.innerHTML = html;

      // Click handlers for linked nodes
      d.querySelectorAll('[data-node-id]').forEach(li => {
        li.addEventListener('click', () => {
          const target = cy.getElementById(li.dataset.nodeId);
          if (target.length > 0) {
            cy.animate({ center: { eles: target }, zoom: 2.5 }, { duration: 300 });
            target.emit('tap');
          }
        });
      });
    }

    // ── Edge tap ────────────────────────────────────────────────────────
    function onEdgeTap(evt) {
      const edge = evt.target;
      const d = document.getElementById('detail');
      d.className = '';
      const pred = edge.data('predicate');
      const predColor = PREDICATE_COLORS[pred] || '#475569';

      let html = `<h2>${edge.data('source')} &rarr; ${edge.data('target')}</h2>`;
      html += `<span class="badge" style="background:${predColor}33;color:${predColor}">${pred}</span>`;
      html += `<table>`;
      html += `<tr><td>Plane</td><td>${edge.data('plane')}</td></tr>`;
      html += `<tr><td>Confidence</td><td>${(edge.data('confidence')*100).toFixed(0)}%</td></tr>`;
      const meta = edge.data('meta');
      if (meta && Object.keys(meta).length > 0) {
        Object.entries(meta).forEach(([k, v]) => {
          html += `<tr><td>${k}</td><td>${v}</td></tr>`;
        });
      }
      html += '</table>';

      html += `<div class="section-label">Endpoints</div><ul>`;
      html += `<li data-node-id="${edge.data('source')}">${edge.data('source')}</li>`;
      html += `<li data-node-id="${edge.data('target')}">${edge.data('target')}</li>`;
      html += '</ul>';

      d.innerHTML = html;

      d.querySelectorAll('[data-node-id]').forEach(li => {
        li.addEventListener('click', () => {
          const target = cy.getElementById(li.dataset.nodeId);
          if (target.length > 0) {
            cy.animate({ center: { eles: target }, zoom: 2.5 }, { duration: 300 });
            target.emit('tap');
          }
        });
      });
    }

    // ── Helpers ─────────────────────────────────────────────────────────
    function clearSelection() {
      clearDimming();
      const d = document.getElementById('detail');
      d.className = 'empty';
      d.innerHTML = '<span>Click a node or edge to inspect</span>';
    }

    function clearDimming() {
      cy.elements().removeClass('dimmed').removeClass('highlighted').removeClass('neighbor');
    }

    function updateStats() {
      const vn = cy.nodes().filter(n => n.visible() && !n.hasClass('faded')).length;
      const ve = cy.edges().filter(e => e.visible() && !e.hasClass('faded')).length;
      const tn = graphData.nodes.length;
      const te = graphData.edges.length;
      document.getElementById('stats').textContent =
        `${tn} nodes, ${te} edges | Visible: ${vn}n ${ve}e`;
    }

    // ── Toolbar ─────────────────────────────────────────────────────────
    document.getElementById('btn-fit').addEventListener('click', () => cy.fit(null, 40));
    document.getElementById('btn-reset').addEventListener('click', () => {
      clearSelection();
      cy.elements().removeClass('faded');
      focusedFramework = '';
      document.getElementById('framework-select').value = '';
      document.getElementById('search').value = '';
      document.querySelectorAll('[data-predicate]').forEach(cb => {
        cb.checked = DEFAULT_ON_PREDICATES.has(cb.dataset.predicate);
      });
      document.querySelectorAll('[data-node-type]').forEach(cb => cb.checked = true);
      document.getElementById('toggle-orphans').checked = false;
      document.getElementById('toggle-labels').checked = true;
      cy.style().selector('node').style('label', 'data(id)').update();
      applyFilters();
      cy.fit(null, 40);
    });
    document.getElementById('btn-png').addEventListener('click', () => {
      const png = cy.png({ bg: '#0f172a', full: true, scale: 2 });
      const a = document.createElement('a');
      a.href = png; a.download = 'grc-knowledge-graph.png'; a.click();
    });

    // Layout
    document.getElementById('layout-select').addEventListener('change', (e) => {
      const name = e.target.value;
      const opts = { name, animate: true, animationDuration: 500, nodeDimensionsIncludeLabels: true };
      if (name === 'cose') {
        opts.animate = false; opts.nodeRepulsion = () => 20000;
        opts.idealEdgeLength = () => 100; opts.gravity = 0.3; opts.numIter = 500;
      }
      if (name === 'breadthfirst') { opts.directed = true; opts.spacingFactor = 0.8; }
      if (name === 'concentric') { opts.concentric = (n) => n.degree(); opts.levelWidth = () => 4; }
      cy.layout(opts).run();
    });

    // Toggles
    document.getElementById('toggle-labels').addEventListener('change', (e) => {
      cy.style().selector('node').style('label', e.target.checked ? 'data(id)' : '').update();
    });
    document.getElementById('toggle-orphans').addEventListener('change', applyFilters);

    // Keyboard: Escape to clear
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        clearSelection();
        document.getElementById('search').value = '';
        cy.nodes().removeClass('highlighted');
      }
    });

    // ── Chat module ─────────────────────────────────────────────────────
    const chatDrawer = document.getElementById('chat-drawer');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    const chatStatus = document.getElementById('chat-status');
    const chatToggleIcon = document.getElementById('chat-toggle-icon');
    const btnChat = document.getElementById('btn-chat');

    let chatHistory = [];
    let chatOpen = false;
    let chatStreaming = false;

    function getSelectedNodeId() {
      const sel = cy?.elements('node:selected');
      return (sel && sel.length > 0) ? sel[0].id() : null;
    }

    function toggleChat() {
      chatOpen = !chatOpen;
      chatDrawer.classList.toggle('collapsed', !chatOpen);
      btnChat.classList.toggle('active', chatOpen);
      chatToggleIcon.innerHTML = chatOpen ? '&#9660;' : '&#9650;';
      if (chatOpen) chatInput.focus();
    }

    btnChat.addEventListener('click', toggleChat);
    document.getElementById('chat-header').addEventListener('click', toggleChat);

    chatInput.addEventListener('input', () => {
      chatInput.style.height = 'auto';
      chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
    });

    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    chatSend.addEventListener('click', sendMessage);

    async function sendMessage() {
      const text = chatInput.value.trim();
      if (!text || chatStreaming) return;

      chatHistory.push({ role: 'user', content: text });
      appendChatBubble('user', text);
      chatInput.value = '';
      chatInput.style.height = 'auto';

      chatStreaming = true;
      chatSend.disabled = true;
      chatStatus.textContent = 'Thinking...';

      const assistantBubble = appendChatBubble('assistant', '');
      let fullResponse = '';

      try {
        const res = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            messages: chatHistory,
            selectedNode: getSelectedNodeId(),
          }),
        });

        if (!res.ok) {
          const err = await res.json().catch(() => ({ error: `HTTP ${res.status}` }));
          throw new Error(err.error || `HTTP ${res.status}`);
        }

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop();

          for (const line of lines) {
            if (!line.startsWith('data: ')) continue;
            const data = JSON.parse(line.slice(6));

            if (data.type === 'delta') {
              fullResponse += data.text;
              renderAssistantBubble(assistantBubble, fullResponse);
            } else if (data.type === 'error') {
              throw new Error(data.text);
            }
          }
        }

        chatHistory.push({ role: 'assistant', content: fullResponse });
      } catch (err) {
        if (!fullResponse) assistantBubble.remove();
        appendChatBubble('error', err.message);
        if (!fullResponse) chatHistory.pop();
      } finally {
        chatStreaming = false;
        chatSend.disabled = false;
        chatStatus.textContent = '';
      }
    }

    function appendChatBubble(role, text) {
      const div = document.createElement('div');
      div.className = `chat-msg ${role}`;
      if (role === 'user' || role === 'error') div.textContent = text;
      chatMessages.appendChild(div);
      chatMessages.scrollTop = chatMessages.scrollHeight;
      return div;
    }

    function renderAssistantBubble(el, markdown) {
      let html = marked.parse(markdown);
      // Make node IDs clickable
      html = html.replace(/\b([A-Z][A-Z0-9]*(?:-[A-Za-z0-9.]+)+)\b/g, (match) => {
        if (graphData && graphData.nodes.some(n => n.id === match)) {
          return `<a class="node-link" data-node-id="${match}">${match}</a>`;
        }
        return match;
      });
      el.innerHTML = html;

      el.querySelectorAll('.node-link').forEach(a => {
        a.addEventListener('click', (e) => {
          e.preventDefault();
          const nodeId = a.dataset.nodeId;
          const target = cy.getElementById(nodeId);
          if (target.length > 0) {
            cy.animate({ center: { eles: target }, zoom: 2.5 }, { duration: 300 });
            target.emit('tap');
          }
        });
      });

      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // ── Run ─────────────────────────────────────────────────────────────
    init();
  </script>
</body>
</html>
